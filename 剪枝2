#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include <chrono>
#include <climits>

using namespace std;
using Clock = chrono::steady_clock;
using TimePoint = chrono::time_point<Clock>;

// ----------------- 常量与全局的定义 -----------------
static const int BOARD_N = 12;       // 棋盘 12 x 12
static const int EMPTY = 0;
static const int BLACK = 1;
static const int WHITE = 2;
static const int WIN_COUNT = 5;

const double PER_STEP_LIMIT = 2.0;   // 每步 2 秒（你的定义）
const double TOTAL_LIMIT = 90.0;     // 每方总时间 90 秒（你的定义）
const double SAFETY_MARGIN = 0.05;   // 小留余量防止超时

// ----------------- 全局变量 -----------------
int board[BOARD_N][BOARD_N];
int myColor = BLACK;
int oppColor = WHITE;
bool inGame = false;
double totalUsedTime = 0.0; // 我方累积耗时（秒）

// 四个方向：水平、竖直、主对角、副对角）
int dirX[4] = { 1, 0, 1, 1 };
int dirY[4] = { 0, 1, 1, -1 };

// 搜索时用的时间控制
TimePoint moveStart;
double perMoveTimeAllowed = 1.9; // 动态调整
bool timeUp = false;

// ----------------- 辅助 -----------------
inline bool onBoard(int r, int c) {
    return r >= 0 && r < BOARD_N && c >= 0 && c < BOARD_N;
}
inline void flushStdout() { cout.flush(); }
inline void safePrintOK() { cout << "OK\n"; flushStdout(); }

// 计算当前 move 已耗时（秒）
inline double elapsedSinceMoveStart() {
    return chrono::duration<double>(Clock::now() - moveStart).count();
}
inline bool checkTimeOut() {
    if (elapsedSinceMoveStart() >= perMoveTimeAllowed - 1e-9) {
        timeUp = true;
        return true;
    }
    return false;
}

// ----------------- 初始化起始棋子，依据你提供的图片： -----------------
// 放置 2x2 棋子：0-based 坐标）
// (5,5) = WHITE, (5,6) = BLACK, (6,5) = BLACK, (6,6) = WHITE
void initBoardWithImageLayout() {
    for (int r = 0; r < BOARD_N; ++r)
        for (int c = 0; c < BOARD_N; ++c)
            board[r][c] = EMPTY;
    // place the 2x2 block
    board[5][5] = WHITE;
    board[5][6] = BLACK;
    board[6][5] = BLACK;
    board[6][6] = WHITE;
}

// ----------------- 胜利判断 -----------------
bool isWinAt(int r, int c, int color) {
    for (int d = 0; d < 4; ++d) {
        int cnt = 1;
        int nr = r + dirX[d], nc = c + dirY[d];
        while (onBoard(nr, nc) && board[nr][nc] == color) { cnt++; nr += dirX[d]; nc += dirY[d]; }
        nr = r - dirX[d]; nc = c - dirY[d];
        while (onBoard(nr, nc) && board[nr][nc] == color) { cnt++; nr -= dirX[d]; nc -= dirY[d]; }
        if (cnt >= WIN_COUNT) return true;
    }
    return false;
}

// ----------------- 盘面评估 - 简化但更精准 -----------------
int evalColor(int color) {
    int score = 0;
    for (int r = 0; r < BOARD_N; ++r) {
        for (int c = 0; c < BOARD_N; ++c) {
            if (board[r][c] != color) continue;
            for (int d = 0; d < 4; ++d) {
                int pr = r - dirX[d], pc = c - dirY[d];
                if (onBoard(pr, pc) && board[pr][pc] == color) continue; // 跳过重复计数
                int len = 0;
                int rr = r, cc = c;
                while (onBoard(rr, cc) && board[rr][cc] == color) { len++; rr += dirX[d]; cc += dirY[d]; }
                bool open1 = false, open2 = false;
                int ar = r - dirX[d], ac = c - dirY[d];
                if (onBoard(ar, ac) && board[ar][ac] == EMPTY) open1 = true;
                if (onBoard(rr, cc) && board[rr][cc] == EMPTY) open2 = true;

                if (len >= 5) score += 1000000;
                else if (len == 4) {
                    if (open1 && open2) score += 50000; // 活四
                    else if (open1 || open2) score += 10000; // 冲四
                }
                else if (len == 3) {
                    if (open1 && open2) score += 5000; // 活三
                    else if (open1 || open2) score += 500; // 眠三
                }
                else if (len == 2) {
                    if (open1 && open2) score += 200; // 活二
                    else if (open1 || open2) score += 30;
                }
                else if (len == 1) {
                    if (open1 && open2) score += 10;
                }
            }
        }
    }
    return score;
}

int evaluateBoard() {
    int myS = evalColor(myColor);
    int oppS = evalColor(oppColor);
    // 根据对手威胁动态调整权重
    if (oppS >= 10000) return myS - oppS * 13 / 10;  // 对手有活四/冲四，必须重视防守
    if (oppS >= 5000) return myS - oppS * 12 / 10;   // 对手有活三，加强防守
    return myS - oppS * 11 / 10;  // 正常情况下略重视防守
}

// ----------------- 候选走法生成 -----------------
vector<pair<int, int>> generateMoves(int radius = 2) {
    vector<pair<int, int>> moves;
    bool any = false;
    for (int r = 0; r < BOARD_N && !any; ++r)
        for (int c = 0; c < BOARD_N; ++c)
            if (board[r][c] != EMPTY) { any = true; break; }
    if (!any) {
        moves.emplace_back(BOARD_N / 2, BOARD_N / 2);
        return moves;
    }
    vector<vector<char>> mark(BOARD_N, vector<char>(BOARD_N, 0));
    for (int r = 0; r < BOARD_N; ++r) {
        for (int c = 0; c < BOARD_N; ++c) {
            if (board[r][c] != EMPTY) {
                for (int dr = -radius; dr <= radius; ++dr)
                    for (int dc = -radius; dc <= radius; ++dc) {
                        int nr = r + dr, nc = c + dc;
                        if (onBoard(nr, nc) && board[nr][nc] == EMPTY) mark[nr][nc] = 1;
                    }
            }
        }
    }
    for (int r = 0; r < BOARD_N; ++r)
        for (int c = 0; c < BOARD_N; ++c)
            if (mark[r][c]) moves.emplace_back(r, c);
    return moves;
}

// ----------------- Alpha-Beta 搜索 - 简化版本 -----------------
int alphaBeta(int depth, int alpha, int beta, int playerColor) {
    if (checkTimeOut()) return evaluateBoard();
    if (depth == 0) return evaluateBoard();

    vector<pair<int, int>> moves = generateMoves();
    if (moves.empty()) return evaluateBoard();

    // 走法排序
    vector<pair<int, int>> sortedMoves;
    for (auto& m : moves) {
        int r = m.first, c = m.second;
        board[r][c] = playerColor;
        // 检查是否直接获胜
        if (isWinAt(r, c, playerColor)) {
            board[r][c] = EMPTY;
            return (playerColor == myColor) ? 10000000 : -10000000;
        }
        int sc = evaluateBoard();
        board[r][c] = EMPTY;
        sortedMoves.emplace_back((playerColor == myColor) ? -sc : sc, (r << 8) | c);
    }
    sort(sortedMoves.begin(), sortedMoves.end());

    if (playerColor == myColor) {
        int value = INT_MIN / 4;
        for (auto& p : sortedMoves) {
            if (checkTimeOut()) break;
            int code = p.second;
            int r = (code >> 8) & 0xFF;
            int c = code & 0xFF;
            board[r][c] = playerColor;
            int val = alphaBeta(depth - 1, alpha, beta, oppColor);
            board[r][c] = EMPTY;
            if (val > value) value = val;
            if (value > alpha) alpha = value;
            if (alpha >= beta) break;
        }
        return value;
    }
    else {
        int value = INT_MAX / 4;
        for (auto& p : sortedMoves) {
            if (checkTimeOut()) break;
            int code = p.second;
            int r = (code >> 8) & 0xFF;
            int c = code & 0xFF;
            board[r][c] = playerColor;
            int val = alphaBeta(depth - 1, alpha, beta, myColor);
            board[r][c] = EMPTY;
            if (val < value) value = val;
            if (value < beta) beta = value;
            if (alpha >= beta) break;
        }
        return value;
    }
}

// ----------------- 检测立即一步棋（赢/挡） -----------------
bool findImmediateWin(int color, pair<int, int>& outMove) {
    vector<pair<int, int>> moves = generateMoves();
    for (auto& mv : moves) {
        int r = mv.first, c = mv.second;
        if (board[r][c] != EMPTY) continue;
        board[r][c] = color;
        bool win = isWinAt(r, c, color);
        board[r][c] = EMPTY;
        if (win) {
            outMove = mv;
            return true;
        }
    }
    return false;
}

// ----------------- 整体搜索，迭代加深，选最佳 -----------------
pair<int, int> findBestMove() {
    vector<pair<int, int>> moves = generateMoves();
    if (moves.empty()) return { BOARD_N / 2, BOARD_N / 2 };

    // 1) 我方直接赢
    pair<int, int> mv;
    if (findImmediateWin(myColor, mv)) return mv;
    // 2) 对手直接赢，要挡
    if (findImmediateWin(oppColor, mv)) return mv;

    pair<int, int> bestMove = moves[0];
    int bestVal = INT_MIN / 4;
    int MAX_DEPTH = 6;

    for (int depth = 1; depth <= MAX_DEPTH; ++depth) {
        if (checkTimeOut()) break;
        int curBestVal = INT_MIN / 4;
        pair<int, int> curBest = bestMove;

        // 在根层用放子后 quick eval 来排序，有利于剪枝
        vector<pair<int, int>> order;
        order.reserve(moves.size());
        vector<pair<int, int>> tmp;
        for (auto& m : moves) {
            int r = m.first, c = m.second;
            if (board[r][c] != EMPTY) continue;
            board[r][c] = myColor;
            int sc = evaluateBoard();
            board[r][c] = EMPTY;
            tmp.emplace_back(-sc, (r << 8) | c);
        }
        sort(tmp.begin(), tmp.end());

        // 深度越深，剪枝越多
        int limit = min((size_t)(30 - depth * 3), tmp.size());
        for (int i = 0; i < limit; ++i) {
            int code = tmp[i].second;
            int r = (code >> 8) & 0xFF;
            int c = code & 0xFF;
            order.emplace_back(r, c);
        }
        if (order.empty()) order = moves;

        for (auto& m : order) {
            if (checkTimeOut()) break;
            int r = m.first, c = m.second;
            if (board[r][c] != EMPTY) continue;
            board[r][c] = myColor;
            int val;
            if (isWinAt(r, c, myColor)) val = 10000000;
            else val = alphaBeta(depth - 1, INT_MIN / 4, INT_MAX / 4, oppColor);
            board[r][c] = EMPTY;
            if (timeUp) break;
            if (val > curBestVal) { curBestVal = val; curBest = m; }
        }

        if (!timeUp && curBestVal > bestVal) {
            bestVal = curBestVal;
            bestMove = curBest;
        }
        if (bestVal >= 9000000) break;
    }

    return bestMove;
}

// ----------------- 主循环：协议实现 -----------------
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // 初始化棋盘为图给的初始布局
    initBoardWithImageLayout();

    string line;
    while (std::getline(cin, line)) {
        if (line.empty()) continue;
        istringstream iss(line);
        string cmd;
        iss >> cmd;
        if (cmd == "START") {
            int field = 1;
            if (iss >> field) {
                if (field == 1) { myColor = BLACK; oppColor = WHITE; }
                else { myColor = WHITE; oppColor = BLACK; }
            }
            else {
                myColor = BLACK; oppColor = WHITE;
            }
            // 重新设置为图的初始棋子，确保每局都以相同初始状态开始。
            initBoardWithImageLayout();
            inGame = true;
            totalUsedTime = 0.0;
            // 发送第1行：回应 OK
            safePrintOK();
        }
        else if (cmd == "PLACE") {
            // PLACE X Y：对手下子，X,Y 是 0-based（先行 再列）
            int X, Y;
            if (!(iss >> X >> Y)) continue;
            if (onBoard(X, Y)) {
                // 如果该位置已经是初始棋子，平台可能不会重复发送初始棋子），
                // 这里/确保覆盖到该颜色（如有必要做颜色记录
                board[X][Y] = oppColor;
            }
        }
        else if (cmd == "TURN") {
            // 轮到我下棋
            if (!inGame) {
                initBoardWithImageLayout();
                inGame = true;
                myColor = BLACK; oppColor = WHITE;
                totalUsedTime = 0.0;
            }
            // 计算本步时间：不能超过每步 2s，且不让总时间超 90s
            double remainingTotal = TOTAL_LIMIT - totalUsedTime;
            if (remainingTotal < 0.0) remainingTotal = 0.0;
            perMoveTimeAllowed = min(PER_STEP_LIMIT - SAFETY_MARGIN, remainingTotal - SAFETY_MARGIN);
            if (perMoveTimeAllowed < 0.05) perMoveTimeAllowed = 0.05;
            moveStart = Clock::now();
            timeUp = false;

            pair<int, int> best = findBestMove();

            double used = elapsedSinceMoveStart();
            totalUsedTime += used;

            // 保险：若选点是非法或已被占，选第一个空位
            if (!onBoard(best.first, best.second) || board[best.first][best.second] != EMPTY) {
                bool found = false;
                for (int r = 0; r < BOARD_N && !found; ++r)
                    for (int c = 0; c < BOARD_N; ++c)
                        if (board[r][c] == EMPTY) { best = { r,c }; found = true; break; }
                if (!found) best = { 0,0 };
            }

            // 输出坐标（先行后列）：0-based，立即输出 flush
            cout << best.first << " " << best.second << "\n";
            flushStdout();
            // 更新棋盘
            board[best.first][best.second] = myColor;
        }
        else if (cmd == "END") {
            break;
        }
        else if (cmd == "DEBUG") {
            string rest;
            getline(iss, rest);
            if (!rest.empty()) cerr << "DEBUG" << rest << endl;
        }
        else {
            // 忽略未知命令
            continue;
        }
    }

    return 0;
}
